[
    {
        "name": "Two Sum",
        "problemNumber": 1,
        "difficulty": "Easy",
        "category": "Array, Hash Table",
        "description": "Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
        "examples": [
            {
                "inputText": "nums = [2,7,11,15], target = 9",
                "outputText": "[0,1]",
                "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
            }
        ],
        "constraints": [
            "2 <= nums.length <= 10^4",
            "-10^9 <= nums[i] <= 10^9",
            "-10^9 <= target <= 10^9",
            "Only one valid answer exists."
        ],
        "starterCode": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:",
        "functionName": "twoSum",
        "testCases": [
            {
                "input": {
                    "nums": [2, 7, 11, 15],
                    "target": 9
                },
                "output": [0, 1]
            },
            {
                "input": {
                    "nums": [3, 2, 4],
                    "target": 6
                },
                "output": [1, 2]
            },
            {
                "input": {
                    "nums": [3, 3],
                    "target": 6
                },
                "output": [0, 1]
            }
        ]
    },
    {
        "name": "Add Two Numbers",
        "problemNumber": 2,
        "difficulty": "Medium",
        "category": "Linked List, Math, Recursion",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
        "examples": [
            {
                "inputText": "l1 = [2,4,3], l2 = [5,6,4]",
                "outputText": "[7,0,8]",
                "explanation": "342 + 465 = 807"
            }
        ],
        "constraints": [
            "The number of nodes in each linked list is in the range <code>[1, 100]</code>",
            "0 <= Node.val <= 9",
            "It is guaranteed that the list represents a number that does not have leading zeros"
        ],
        "starterCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:",
        "functionName": "addTwoNumbers",
        "inputTypes": ["linked_list", "linked_list"],
        "testCases": [
            {
                "input": {
                    "l1": [2, 4, 3],
                    "l2": [5, 6, 4]
                },
                "output": [7, 0, 8]
            },
            {
                "input": {
                    "l1": [0],
                    "l2": [0]
                },
                "output": [0]
            },
            {
                "input": {
                    "l1": [9, 9, 9, 9, 9, 9, 9],
                    "l2": [9, 9, 9, 9]
                },
                "output": [8, 9, 9, 9, 0, 0, 0, 1]
            }
        ]
    },
    {
        "name": "Longest Substring Without Repeating Characters",
        "problemNumber": 3,
        "difficulty": "Medium",
        "category": "Hash Table, String, Sliding Window",
        "description": "Given a string <code>s</code>, find the length of the longest substring without repeating characters.",
        "examples": [
            {
                "inputText": "s = \"abcabcbb\"",
                "outputText": "3",
                "explanation": "The longest substring is \"abc\", with the length of 3."
            }
        ],
        "constraints": [
            "0 <= s.length <= 5 * 10^4",
            "<code>s</code> consists of English letters, digits, symbols and spaces"
        ],
        "starterCode": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:",
        "functionName": "lengthOfLongestSubstring",
        "testCases": [
            {
                "input": {
                    "s": "abcabcbb"
                },
                "output": 3
            },
            {
                "input": {
                    "s": "bbbbb"
                },
                "output": 1
            },
            {
                "input": {
                    "s": "pwwkew"
                },
                "output": 3
            }
        ]
    },
    {
        "name": "Median of Two Sorted Arrays",
        "problemNumber": 4,
        "difficulty": "Hard",
        "category": "Array, Binary Search, Divide and Conquer",
        "description": "Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)).",
        "examples": [
            {
                "inputText": "nums1 = [1,3], nums2 = [2]",
                "outputText": "2.00000",
                "explanation": "Merged array = [1,2,3] and median is 2."
            }
        ],
        "constraints": [
            "nums1.length == m",
            "nums2.length == n",
            "0 <= m <= 1000",
            "0 <= n <= 1000",
            "1 <= m + n <= 2000",
            "-10^6 <= nums1[i], nums2[i] <= 10^6"
        ],
        "starterCode": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:",
        "functionName": "findMedianSortedArrays",
        "testCases": [
            {
                "input": {
                    "nums1": [1, 3],
                    "nums2": [2]
                },
                "output": 2.0
            },
            {
                "input": {
                    "nums1": [1, 2],
                    "nums2": [3, 4]
                },
                "output": 2.5
            }
        ]
    },
    {
        "name": "Longest Palindromic Substring",
        "problemNumber": 5,
        "difficulty": "Medium",
        "category": "String, Dynamic Programming",
        "description": "Given a string <code>s</code>, return the longest palindromic substring in <code>s</code>.",
        "examples": [
            {
                "inputText": "s = \"babad\"",
                "outputText": "\"bab\"",
                "explanation": "\"aba\" is also a valid answer."
            }
        ],
        "constraints": [
            "1 <= s.length <= 1000",
            "<code>s</code> consist of only digits and English letters."
        ],
        "starterCode": "class Solution:\n    def longestPalindrome(self, s: str) -> str:",
        "functionName": "longestPalindrome",
        "testCases": [
            {
                "input": {
                    "s": "babad"
                },
                "output": "aba"
            },
            {
                "input": {
                    "s": "cbbd"
                },
                "output": "bb"
            }
        ]
    },
    {
        "name": "Zigzag Conversion",
        "problemNumber": 6,
        "difficulty": "Medium",
        "category": "String",
        "description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern by adding line breaks). And then read line by line: \"PAHNAPLSIIGYIR\"",
        "examples": [
            {
                "inputText": "s = \"PAYPALISHIRING\", numRows = 3",
                "outputText": "\"PAHNAPLSIIGYIR\"",
                "img": "https://assets.leetcode.com/uploads/2021/04/08/leetcode-example-1.png"
            }
        ],
        "constraints": [
            "1 <= s.length <= 1000",
            "<code>s</code> consists of English letters (lower-case and upper-case), ',' and '.'",
            "1 <= numRows <= 1000"
        ],
        "starterCode": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:",
        "functionName": "convert",
        "testCases": [
            {
                "input": {
                    "s": "PAYPALISHIRING",
                    "numRows": 3
                },
                "output": "PAHNAPLSIIGYIR"
            },
            {
                "input": {
                    "s": "PAYPALISHIRING",
                    "numRows": 4
                },
                "output": "PINALSIGYAHRPI"
            },
            {
                "input": {
                    "s": "A",
                    "numRows": 1
                },
                "output": "A"
            }
        ]
    },
    {
        "name": "Reverse Integer",
        "problemNumber": 7,
        "difficulty": "Medium",
        "category": "Math",
        "description": "Given a signed 32-bit integer <code>x</code>, return <code>x</code> with its digits reversed. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2^31, 2^31 - 1]</code>, then return 0.",
        "examples": [
            {
                "inputText": "x = 123",
                "outputText": "321",
                "explanation": null
            }
        ],
        "constraints": ["-2^31 <= x <= 2^31 - 1"],
        "starterCode": "class Solution:\n    def reverse(self, x: int) -> int:",
        "functionName": "reverse",
        "testCases": [
            {
                "input": {
                    "x": 123
                },
                "output": 321
            },
            {
                "input": {
                    "x": -123
                },
                "output": -321
            },
            {
                "input": {
                    "x": 120
                },
                "output": 21
            }
        ]
    },
    {
        "name": "String to Integer (atoi)",
        "problemNumber": 8,
        "difficulty": "Medium",
        "category": "String",
        "description": "Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++'s <code>atoi</code> function).",
        "examples": [
            {
                "inputText": "s = \"42\"",
                "outputText": "42",
                "explanation": "The underlined characters are what is read in, the caret is the current position."
            }
        ],
        "constraints": [
            "0 <= s.length <= 200",
            "<code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), ' ', '+', '-', and '.'."
        ],
        "starterCode": "class Solution:\n    def myAtoi(self, s: str) -> int:",
        "functionName": "myAtoi",
        "testCases": [
            {
                "input": {
                    "s": "42"
                },
                "output": 42
            },
            {
                "input": {
                    "s": "   -42"
                },
                "output": -42
            },
            {
                "input": {
                    "s": "4193 with words"
                },
                "output": 4193
            }
        ]
    },
    {
        "name": "Palindrome Number",
        "problemNumber": 9,
        "difficulty": "Easy",
        "category": "Math",
        "description": "Given an integer <code>x</code>, return <code>true</code> if <code>x</code> is a palindrome, and <code>false</code> otherwise.",
        "examples": [
            {
                "inputText": "x = 121",
                "outputText": "true",
                "explanation": "121 reads as 121 from left to right and from right to left."
            }
        ],
        "constraints": ["-2^31 <= x <= 2^31 - 1"],
        "starterCode": "class Solution:\n    def isPalindrome(self, x: int) -> bool:",
        "functionName": "isPalindrome",
        "testCases": [
            {
                "input": {
                    "x": 121
                },
                "output": true
            },
            {
                "input": {
                    "x": -121
                },
                "output": false
            },
            {
                "input": {
                    "x": 10
                },
                "output": false
            }
        ]
    },
    {
        "name": "Regular Expression Matching",
        "problemNumber": 10,
        "difficulty": "Hard",
        "category": "String, Dynamic Programming, Recursion",
        "description": "Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for '.' and '*' where: '.' Matches any single character '* Matches zero or more of the preceding element.",
        "examples": [
            {
                "inputText": "s = \"aa\", p = \"a\"",
                "outputText": "false",
                "explanation": "'a' does not match the entire string 'aa'."
            }
        ],
        "constraints": [
            "1 <= s.length <= 20",
            "1 <= p.length <= 30",
            "<code>s</code> contains only lowercase English letters.",
            "<code>p</code> contains only lowercase English letters, '.', and '*'.",
            "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
        ],
        "starterCode": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:",
        "functionName": "isMatch",
        "testCases": [
            {
                "input": {
                    "s": "aa",
                    "p": "a"
                },
                "output": false
            },
            {
                "input": {
                    "s": "aa",
                    "p": "a*"
                },
                "output": true
            },
            {
                "input": {
                    "s": "ab",
                    "p": ".*"
                },
                "output": true
            }
        ]
    },
    {
        "name": "Container With Most Water",
        "problemNumber": 11,
        "difficulty": "Medium",
        "category": "Array, Two Pointers, Greedy",
        "description": "You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i-th</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>. Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
        "examples": [
            {
                "inputText": "height = [1,8,6,2,5,4,8,3,7]",
                "outputText": "49",
                "explanation": "The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.",
                "img": "https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"
            },
            {
                "inputText": "height = [1,1]",
                "outputText": "1"
            }
        ],
        "constraints": [
            "2 <= n <= 10^5",
            "0 <= <code>height[i]</code> <= 10^4"
        ],
        "starterCode": "class Solution:\n    def maxArea(self, height: List[int]) -> int:",
        "functionName": "maxArea",
        "testCases": [
            {
                "input": {
                    "height": [1, 8, 6, 2, 5, 4, 8, 3, 7]
                },
                "output": 49
            },
            {
                "input": {
                    "height": [1, 1]
                },
                "output": 1
            }
        ]
    },
    {
        "name": "Integer to Roman",
        "problemNumber": 12,
        "difficulty": "Medium",
        "category": "Hash Table, Math, String",
        "description": "Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>. Given an integer, convert it to a Roman numeral.",
        "examples": [
            {
                "inputText": "num = 3",
                "outputText": "\"III\"",
                "explanation": "3 is represented as 3 ones."
            },
            {
                "inputText": "num = 58",
                "outputText": "\"LVIII\"",
                "explanation": "L = 50, V = 5, III = 3."
            },
            {
                "inputText": "num = 1994",
                "outputText": "\"MCMXCIV\"",
                "explanation": "M = 1000, CM = 900, XC = 90, IV = 4."
            }
        ],
        "constraints": ["1 <= num <= 3999"],
        "starterCode": "class Solution:\n    def intToRoman(self, num: int) -> str:",
        "functionName": "intToRoman",
        "testCases": [
            {
                "input": {
                    "num": 3
                },
                "output": "III"
            },
            {
                "input": {
                    "num": 58
                },
                "output": "LVIII"
            },
            {
                "input": {
                    "num": 1994
                },
                "output": "MCMXCIV"
            }
        ]
    },
    {
        "name": "Roman to Integer",
        "problemNumber": 13,
        "difficulty": "Easy",
        "category": "Hash Table, Math, String",
        "description": "Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>. For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two ones added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:",
        "examples": [
            {
                "inputText": "s = \"III\"",
                "outputText": "3",
                "explanation": "III = 3"
            },
            {
                "inputText": "s = \"LVIII\"",
                "outputText": "58",
                "explanation": "L = 50, V = 5, III = 3"
            },
            {
                "inputText": "s = \"MCMXCIV\"",
                "outputText": "1994",
                "explanation": "M = 1000, CM = 900, XC = 90, IV = 4"
            }
        ],
        "constraints": [
            "1 <= s.length <= 15",
            "<code>s</code> contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M')"
        ],
        "starterCode": "class Solution:\n    def romanToInt(self, s: str) -> int:",
        "functionName": "romanToInt",
        "testCases": [
            {
                "input": {
                    "s": "III"
                },
                "output": 3
            },
            {
                "input": {
                    "s": "LVIII"
                },
                "output": 58
            },
            {
                "input": {
                    "s": "MCMXCIV"
                },
                "output": 1994
            }
        ]
    },
    {
        "name": "Longest Common Prefix",
        "problemNumber": 14,
        "difficulty": "Easy",
        "category": "String",
        "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string <code>\"\"</code>.",
        "examples": [
            {
                "inputText": "strs = [\"flower\",\"flow\",\"flight\"]",
                "outputText": "\"fl\"",
                "explanation": "The longest common prefix is \"fl\"."
            },
            {
                "inputText": "strs = [\"dog\",\"racecar\",\"car\"]",
                "outputText": "\"\"",
                "explanation": "There is no common prefix among the input strings."
            }
        ],
        "constraints": [
            "1 <= strs.length <= 200",
            "0 <= <code>strs[i].length</code> <= 200",
            "<code>strs[i]</code> consists of only lowercase English letters"
        ],
        "starterCode": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:",
        "functionName": "longestCommonPrefix",
        "testCases": [
            {
                "input": {
                    "strs": ["flower", "flow", "flight"]
                },
                "output": "fl"
            },
            {
                "input": {
                    "strs": ["dog", "racecar", "car"]
                },
                "output": ""
            }
        ]
    },
    {
        "name": "3Sum",
        "problemNumber": 15,
        "difficulty": "Medium",
        "category": "Array, Two Pointers, Sorting",
        "description": "Given an integer array <code>nums</code>, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>. Notice that the solution set must not contain duplicate triplets.",
        "examples": [
            {
                "inputText": "nums = [-1,0,1,2,-1,-4]",
                "outputText": "[[-1,-1,2],[-1,0,1]]",
                "explanation": "The output contains two triplets satisfying the condition."
            },
            {
                "inputText": "nums = [0,1,1]",
                "outputText": "[]",
                "explanation": "No triplets sum up to zero."
            },
            {
                "inputText": "nums = [0,0,0]",
                "outputText": "[[0,0,0]]",
                "explanation": "The only possible triplet sums up to zero."
            }
        ],
        "constraints": ["3 <= nums.length <= 3000", "-10^5 <= nums[i] <= 10^5"],
        "starterCode": "class Solution:\n   def threeSum(self, nums: List[int]) -> List[List[int]]:",
        "functionName": "threeSum",
        "testCases": [
            {
                "input": {
                    "nums": [-1, 0, 1, 2, -1, -4]
                },
                "output": [
                    [-1, -1, 2],
                    [-1, 0, 1]
                ]
            },
            {
                "input": {
                    "nums": [0, 1, 1]
                },
                "output": []
            },
            {
                "input": {
                    "nums": [0, 0, 0]
                },
                "output": [[0, 0, 0]]
            }
        ]
    },
    {
        "name": "3Sum Closest",
        "problemNumber": 16,
        "difficulty": "Medium",
        "category": "Array, Two Pointers, Sorting",
        "description": "Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
        "examples": [
            {
                "inputText": "nums = [-1,2,1,-4], target = 1",
                "outputText": "2",
                "explanation": "The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)."
            },
            {
                "inputText": "nums = [0,0,0], target = 1",
                "outputText": "0",
                "explanation": "The sum that is exactly closest to the target is 0."
            }
        ],
        "constraints": [
            "3 <= nums.length <= 10^3",
            "-10^3 <= nums[i] <= 10^3",
            "-10^4 <= target <= 10^4"
        ],
        "starterCode": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:",
        "functionName": "threeSumClosest",
        "testCases": [
            {
                "input": {
                    "nums": [-1, 2, 1, -4],
                    "target": 1
                },
                "output": 2
            },
            {
                "input": {
                    "nums": [0, 0, 0],
                    "target": 1
                },
                "output": 0
            }
        ]
    },
    {
        "name": "Letter Combinations of a Phone Number",
        "problemNumber": 17,
        "difficulty": "Medium",
        "category": "Hash Table, String, Backtracking",
        "description": "Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
        "examples": [
            {
                "inputText": "digits = \"23\"",
                "outputText": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
                "explanation": "The image below shows the mapping of digits to letters on telephone buttons: [2: abc, 3: def]"
            },
            {
                "inputText": "digits = \"\"",
                "outputText": "[]"
            },
            {
                "inputText": "digits = \"2\"",
                "outputText": "[\"a\",\"b\",\"c\"]"
            }
        ],
        "constraints": [
            "0 <= digits.length <= 4",
            "<code>digits</code> contains digits from '2' to '9'"
        ],
        "starterCode": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:",
        "functionName": "letterCombinations",
        "testCases": [
            {
                "input": {
                    "digits": "23"
                },
                "output": ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
            },
            {
                "input": {
                    "digits": ""
                },
                "output": []
            },
            {
                "input": {
                    "digits": "2"
                },
                "output": ["a", "b", "c"]
            }
        ]
    },
    {
        "name": "4Sum",
        "problemNumber": 18,
        "difficulty": "Medium",
        "category": "Array, Two Pointers, Sorting",
        "description": "Given an array <code>nums</code> of <code>n</code> integers, return an array of all the unique quadruplets <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that: \n1. <code>0 <= a, b, c, d < n</code>\n2. <code>a, b, c, d</code> are distinct\n3. <code>nums[a] + nums[b] + nums[c] + nums[d] == target</code>\nNotice that the solution set must not contain duplicate quadruplets.",
        "examples": [
            {
                "inputText": "nums = [1,0,-1,0,-2,2], target = 0",
                "outputText": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
                "explanation": "The four numbers whose sum is zero."
            },
            {
                "inputText": "nums = [2,2,2,2,2], target = 8",
                "outputText": "[[2,2,2,2]]"
            }
        ],
        "constraints": [
            "1 <= nums.length <= 200",
            "-10^9 <= nums[i] <= 10^9",
            "-10^9 <= target <= 10^9"
        ],
        "starterCode": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:",
        "functionName": "fourSum",
        "testCases": [
            {
                "input": {
                    "nums": [1, 0, -1, 0, -2, 2],
                    "target": 0
                },
                "output": [
                    [-2, -1, 1, 2],
                    [-2, 0, 0, 2],
                    [-1, 0, 0, 1]
                ]
            },
            {
                "input": {
                    "nums": [2, 2, 2, 2, 2],
                    "target": 8
                },
                "output": [[2, 2, 2, 2]]
            }
        ]
    },
    {
        "name": "Remove Nth Node From End of List",
        "problemNumber": 19,
        "difficulty": "Medium",
        "category": "Linked List, Two Pointers",
        "description": "Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.",
        "examples": [
            {
                "inputText": "head = [1,2,3,4,5], n = 2",
                "outputText": "[1,2,3,5]",
                "explanation": "After removing the second node from the end, the linked list becomes [1,2,3,5].",
                "img": "https://assets.leetcode.com/uploads/2020/10/03/remove-nth-node.jpg"
            },
            {
                "inputText": "head = [1], n = 1",
                "outputText": "[]",
                "explanation": "When n = 1, the head node is removed, resulting in an empty list."
            },
            {
                "inputText": "head = [1,2], n = 1",
                "outputText": "[1]",
                "explanation": "Removing the last node leaves [1]."
            }
        ],
        "constraints": [
            "The number of nodes in the list is <code>sz</code>.",
            "1 <= sz <= 30",
            "0 <= <code>Node.val</code> <= 100",
            "1 <= n <= sz"
        ],
        "starterCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:",
        "functionName": "removeNthFromEnd",
        "testCases": [
            {
                "input": {
                    "head": [1, 2, 3, 4, 5],
                    "n": 2
                },
                "output": [1, 2, 3, 5]
            },
            {
                "input": {
                    "head": [1],
                    "n": 1
                },
                "output": []
            },
            {
                "input": {
                    "head": [1, 2],
                    "n": 1
                },
                "output": [1]
            }
        ]
    },
    {
        "name": "Valid Parentheses",
        "problemNumber": 20,
        "difficulty": "Easy",
        "category": "String, Stack",
        "description": "Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid. An input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
        "examples": [
            {
                "inputText": "s = \"()\"",
                "outputText": "true"
            },
            {
                "inputText": "s = \"()[]{}\"",
                "outputText": "true"
            },
            {
                "inputText": "s = \"(]\"",
                "outputText": "false"
            }
        ],
        "constraints": [
            "1 <= s.length <= 10^4",
            "<code>s</code> consists of parentheses only '()[]{}'"
        ],
        "starterCode": "class Solution:\n    def isValid(self, s: str) -> bool:",
        "functionName": "isValid",
        "testCases": [
            {
                "input": {
                    "s": "()"
                },
                "output": true
            },
            {
                "input": {
                    "s": "()[]{}"
                },
                "output": true
            },
            {
                "input": {
                    "s": "(]"
                },
                "output": false
            }
        ]
    },
    {
        "name": "Merge Two Sorted Lists",
        "problemNumber": 21,
        "difficulty": "Easy",
        "category": "Linked List, Recursion",
        "description": "You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
        "functionName": "mergeTwoLists",
        "examples": [
            {
                "inputText": "list1 = [1,2,4], list2 = [1,3,4]",
                "outputText": "[1,1,2,3,4,4]",
                "explanation": "The nodes of both lists are merged in a sorted order."
            },
            {
                "inputText": "list1 = [], list2 = []",
                "outputText": "[]"
            },
            {
                "inputText": "list1 = [], list2 = [0]",
                "outputText": "[0]"
            }
        ],
        "constraints": [
            "The number of nodes in both lists is in the range <code>[0, 50]</code>",
            "-100 <= <code>Node.val</code> <= 100",
            "Both <code>list1</code> and <code>list2</code> are sorted in non-decreasing order"
        ],
        "starterCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        ",
        "testCases": [
            {
                "input": {
                    "list1": [1, 2, 4],
                    "list2": [1, 3, 4]
                },
                "output": [1, 1, 2, 3, 4, 4]
            },
            {
                "input": {
                    "list1": [],
                    "list2": []
                },
                "output": []
            },
            {
                "input": {
                    "list1": [],
                    "list2": [0]
                },
                "output": [0]
            }
        ]
    },
    {
        "name": "Generate Parentheses",
        "problemNumber": 22,
        "difficulty": "Medium",
        "category": "String, Dynamic Programming, Backtracking",
        "description": "Given <code>n</code> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
        "functionName": "generateParenthesis",
        "examples": [
            {
                "inputText": "n = 3",
                "outputText": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
                "explanation": "All valid combinations of parentheses."
            },
            {
                "inputText": "n = 1",
                "outputText": "[\"()\"]"
            }
        ],
        "constraints": ["1 <= n <= 8"],
        "starterCode": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        ",
        "testCases": [
            {
                "input": {
                    "n": 3
                },
                "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]
            },
            {
                "input": {
                    "n": 1
                },
                "output": ["()"]
            }
        ]
    },
    {
        "name": "Merge k Sorted Lists",
        "problemNumber": 23,
        "difficulty": "Hard",
        "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
        "description": "You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
        "functionName": "mergeKLists",
        "examples": [
            {
                "inputText": "lists = [[1,4,5],[1,3,4],[2,6]]",
                "outputText": "[1,1,2,3,4,4,5,6]",
                "explanation": "The linked-lists are merged into one sorted linked-list."
            },
            {
                "inputText": "lists = []",
                "outputText": "[]"
            },
            {
                "inputText": "lists = [[]]",
                "outputText": "[]"
            }
        ],
        "constraints": [
            "<code>k == lists.length</code>",
            "0 <= k <= 10^4",
            "0 <= lists[i].length <= 500",
            "-10^4 <= lists[i][j] <= 10^4",
            "<code>lists[i]</code> is sorted in ascending order",
            "The sum of <code>lists[i].length</code> will not exceed 10^4"
        ],
        "starterCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        ",
        "testCases": [
            {
                "input": {
                    "lists": [
                        [1, 4, 5],
                        [1, 3, 4],
                        [2, 6]
                    ]
                },
                "output": [1, 1, 2, 3, 4, 4, 5, 6]
            },
            {
                "input": {
                    "lists": []
                },
                "output": []
            },
            {
                "input": {
                    "lists": [[]]
                },
                "output": []
            }
        ]
    },
    {
        "name": "Swap Nodes in Pairs",
        "problemNumber": 24,
        "difficulty": "Medium",
        "category": "Linked List, Recursion",
        "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the nodes (i.e., only nodes themselves may be changed).",
        "functionName": "swapPairs",
        "examples": [
            {
                "inputText": "head = [1,2,3,4]",
                "outputText": "[2,1,4,3]",
                "explanation": "Nodes are swapped pairwise."
            },
            {
                "inputText": "head = []",
                "outputText": "[]"
            },
            {
                "inputText": "head = [1]",
                "outputText": "[1]"
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range <code>[0, 100]</code>",
            "0 <= <code>Node.val</code> <= 100"
        ],
        "starterCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ",
        "testCases": [
            {
                "input": {
                    "head": [1, 2, 3, 4]
                },
                "output": [2, 1, 4, 3]
            },
            {
                "input": {
                    "head": []
                },
                "output": []
            },
            {
                "input": {
                    "head": [1]
                },
                "output": [1]
            }
        ]
    },
    {
        "name": "Reverse Nodes in k-Group",
        "problemNumber": 25,
        "difficulty": "Hard",
        "category": "Linked List, Recursion",
        "description": "Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return the modified list. <code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.",
        "functionName": "reverseKGroup",
        "examples": [
            {
                "inputText": "head = [1,2,3,4,5], k = 2",
                "outputText": "[2,1,4,3,5]",
                "explanation": "Nodes are reversed in groups of 2."
            },
            {
                "inputText": "head = [1,2,3,4,5], k = 3",
                "outputText": "[3,2,1,4,5]",
                "explanation": "Nodes are reversed in groups of 3."
            }
        ],
        "constraints": [
            "The number of nodes in the list is <code>n</code>",
            "1 <= k <= n <= 5000",
            "0 <= <code>Node.val</code> <= 1000"
        ],
        "starterCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        ",
        "testCases": [
            {
                "input": {
                    "head": [1, 2, 3, 4, 5],
                    "k": 2
                },
                "output": [2, 1, 4, 3, 5]
            },
            {
                "input": {
                    "head": [1, 2, 3, 4, 5],
                    "k": 3
                },
                "output": [3, 2, 1, 4, 5]
            }
        ]
    },
    {
        "name": "Remove Duplicates from Sorted Array",
        "problemNumber": 26,
        "difficulty": "Easy",
        "category": "Array, Two Pointers",
        "description": "Given an integer array <code>nums</code> sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in <code>nums</code>. Consider the number of unique elements of <code>nums</code> to be <code>k</code>, to get accepted, you need to do the following things:\n1. Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the unique elements in the order they were present in <code>nums</code> initially.\n2. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.",
        "functionName": "removeDuplicates",
        "examples": [
            {
                "inputText": "nums = [1,1,2]",
                "outputText": "2, nums = [1,2,_]",
                "explanation": "Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores)."
            },
            {
                "inputText": "nums = [0,0,1,1,1,2,2,3,3,4]",
                "outputText": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
                "explanation": "Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 3 * 10^4",
            "-100 <= nums[i] <= 100",
            "<code>nums</code> is sorted in non-decreasing order"
        ],
        "starterCode": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ",
        "testCases": [
            {
                "input": {
                    "nums": [1, 1, 2]
                },
                "output": 2
            },
            {
                "input": {
                    "nums": [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
                },
                "output": 5
            }
        ]
    }
]
